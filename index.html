<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Spore Drive Idle</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      background: radial-gradient(circle at top, #1b2a3a 0%, #05060a 60%, #020308 100%);
      color: #e5f2ff;
      min-height: 100vh;
      display: flex;
      justify-content: center;
    }

    .app {
      width: 100%;
      max-width: 480px;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    header {
      text-align: center;
    }

    header h1 {
      font-size: 1.5rem;
      letter-spacing: 0.05em;
      margin-bottom: 0.15rem;
    }

    header p {
      font-size: 0.85rem;
      opacity: 0.85;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 0.5rem;
      margin-top: 0.6rem;
    }

    .card {
      background: rgba(8, 16, 30, 0.95);
      border-radius: 0.7rem;
      padding: 0.55rem 0.7rem;
      border: 1px solid rgba(120, 180, 255, 0.3);
    }

    .stat-label {
      font-size: 0.78rem;
      opacity: 0.75;
    }

    .stat-value {
      font-size: 1rem;
      margin-top: 0.1rem;
    }

    .main-button-wrapper {
      margin-top: 0.7rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.15rem;
    }

    .main-button {
      user-select: none;
      -webkit-user-select: none;
      touch-action: none;
      cursor: pointer;
      width: 100%;
      max-width: 360px;
      padding: 1rem;
      border-radius: 999px;
      border: none;
      font-size: 1.1rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      background: linear-gradient(135deg, #3bb2ff, #78ffce);
      color: #02111e;
      box-shadow: 0 0.4rem 1rem rgba(0, 0, 0, 0.6);
      touch-action: manipulation;
      transition: transform 0.08s ease, box-shadow 0.08s ease;
    }

    .main-button:active,
    .main-button.pulse {
      transform: scale(0.96);
      box-shadow: 0 0.25rem 0.7rem rgba(0, 0, 0, 0.9);
    }

    .small-text {
      font-size: 0.78rem;
      opacity: 0.9;
      text-align: center;
    }

    .readout {
      min-height: 1.1rem;
      font-size: 0.83rem;
      text-align: center;
      opacity: 0.95;
      margin-top: 0.25rem;
    }

    .section-title {
      font-size: 0.92rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      opacity: 0.8;
      margin-top: 0.7rem;
      padding-bottom: 0.25rem;
      border-bottom: 1px solid rgba(120, 180, 255, 0.4);
    }

    .upgrades-list {
      max-height: 220px;
      overflow-y: auto;
      margin-top: 0.4rem;
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
      padding-right: 0.2rem;
    }

    .upgrade-card {
      background: rgba(5, 12, 26, 0.96);
      border-radius: 0.6rem;
      padding: 0.55rem 0.6rem;
      border: 1px solid rgba(80, 130, 210, 0.5);
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
      font-size: 0.8rem;
    }

    .upgrade-top {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 0.4rem;
    }

    .upgrade-name {
      font-weight: 600;
      font-size: 0.86rem;
    }

    .upgrade-level {
      font-size: 0.76rem;
      opacity: 0.7;
    }

    .upgrade-desc {
      opacity: 0.9;
    }

    .upgrade-bottom {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.6rem;
    }

    .upgrade-cost {
      font-size: 0.78rem;
      opacity: 0.9;
    }

    .btn-upgrade {
      padding: 0.25rem 0.65rem;
      border-radius: 999px;
      border: none;
      font-size: 0.78rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      background: linear-gradient(135deg, #1b8cff, #48ffd2);
      color: #020c14;
      touch-action: manipulation;
    }

    .btn-upgrade:disabled {
      background: rgba(70, 90, 120, 0.9);
      color: rgba(215, 225, 245, 0.7);
    }

    .save-row {
      margin-top: 0.5rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.76rem;
      flex-wrap: wrap;
    }

    .btn-small {
      padding: 0.25rem 0.65rem;
      border-radius: 999px;
      border: 1px solid rgba(120, 180, 255, 0.6);
      background: rgba(5, 12, 22, 0.95);
      color: #e5f2ff;
      font-size: 0.74rem;
      touch-action: manipulation;
    }

    .save-status.flash {
      color: #78ffce;
    }

    .alignments {
      margin-top: 0.35rem;
      font-size: 0.78rem;
    }

    .align-card {
      background: rgba(10, 18, 35, 0.98);
      border-radius: 0.6rem;
      padding: 0.55rem 0.6rem;
      border: 1px solid rgba(160, 130, 255, 0.7);
      margin-top: 0.35rem;
    }

    .align-title {
      font-size: 0.84rem;
      font-weight: 600;
      margin-bottom: 0.15rem;
    }

    .align-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 0.3rem;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .hint {
      font-size: 0.75rem;
      opacity: 0.8;
      margin-top: 0.15rem;
    }

    .sphere-system-row {
      margin-top: 0.3rem;
      padding-top: 0.3rem;
      border-top: 1px solid rgba(120, 180, 255, 0.25);
    }

    .sphere-system-title {
      font-size: 0.82rem;
      font-weight: 600;
    }

    footer {
      font-size: 0.68rem;
      text-align: center;
      opacity: 0.6;
      margin-top: 0.4rem;
    }

    .recommended {
      outline: 1px solid rgba(120, 255, 200, 0.9);
      box-shadow: 0 0 8px rgba(120, 255, 200, 0.5);
    }

    .badge {
      font-size: 0.65rem;
      padding: 0.1rem 0.35rem;
      border-radius: 999px;
      border: 1px solid rgba(180, 240, 255, 0.7);
      margin-left: 0.25rem;
      opacity: 0.9;
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Spore Drive Idle</h1>
      <p>Black alert: you are Discovery’s spore drive interface. Keep the mycelial river flowing.</p>

      <div class="stats-grid">
        <div class="card">
          <div class="stat-label">Mycelial Charge (MC)</div>
          <div class="stat-value" id="statSporeEnergy">0</div>
        </div>
        <div class="card">
          <div class="stat-label">Gain Rate</div>
          <div class="stat-value">
            <span id="statPerTap">1</span> / manual jump<br />
            <span id="statPerSec">0</span> / passive flow
          </div>
        </div>
        <div class="card">
          <div class="stat-label">Lifetime Mycelial Throughput</div>
          <div class="stat-value" id="statTotalGenerated">0</div>
        </div>
        <div class="card">
          <div class="stat-label">Astromycology Insight (AI)</div>
          <div class="stat-value" id="statRI">0</div>
        </div>
      </div>
    </header>

    <div class="main-button-wrapper">
      <button id="btnTap" class="main-button" onclick="handleTap(1)">Black Alert – Engage</button>
      <div class="small-text">
        Tap or hold to trigger spore jumps. Multi-finger holds simulate Stamets running hot.
      </div>
    </div>

    <div class="readout" id="readout">
      Stamets: “We’re synced to the mycelial network. Start feeding it charge when you’re ready.”
    </div>

    <div class="section-title">Engineering Upgrades</div>
    <div class="upgrades-list" id="upgradesList"></div>

    <div class="section-title">Bridge & Sphere Archive</div>
    <div class="card">
      <div class="save-row">
        <div class="save-status" id="saveStatus">Last log sync: none</div>
        <div>
          <button class="btn-small" id="btnSave">Sync to ship’s log</button>
          <button class="btn-small" id="btnReset">Wipe all records</button>
        </div>
      </div>
      <div class="hint" id="offlineReport"></div>
      <div class="hint" id="sphereSummary"></div>
      <div class="save-row">
        <div class="save-status" id="sphereDetail">Sphere Data: 0 SDF | Archive Syncs: 0 | Potential this run: 0</div>
        <button class="btn-small" id="btnSync">Synchronize with Sphere Archive</button>
      </div>
    </div>

    <div class="section-title">Sphere Archive Interface</div>
    <div class="card">
      <div class="save-row">
        <div>Available Sphere Data: <span id="sphereAvailable">0</span> SDF</div>
      </div>
      <div class="hint" id="sphereHint">
        Each completed run is compressed into Sphere Data Fragments. Spend them here to bias future timelines.
      </div>
      <div id="sphereSystemsContainer"></div>
    </div>

    <div class="section-title" id="zoraSectionTitle">Zora – Autonomous Systems</div>
    <div class="card" id="zoraPanel">
      <div id="zoraStatus" class="hint">
        Sphere cognitive patterns incomplete. No emergent personality detected.
      </div>
      <div id="zoraAbilities" class="hint"></div>
    </div>

    <div class="section-title">Doctrine & Factions</div>
    <div class="alignments">
      <div class="hint" id="alignHint">
        As Discovery’s imprint on the network grows, factions take interest in how you use the drive.
      </div>
      <div id="alignmentsContainer"></div>
    </div>

    <footer>
      Unofficial fan project. Support the queer astromycologists in your sector.
    </footer>
  </div>

  <script>
    // ---------- UTILITIES ----------
    function formatNumber(n) {
      if (!isFinite(n)) return "0";
      if (n < 1000) return n.toFixed(0);
      const units = ["K", "M", "B", "T", "Q"];
      let unitIndex = -1;
      let value = n;
      while (value >= 1000 && unitIndex < units.length - 1) {
        value /= 1000;
        unitIndex++;
      }
      return value.toFixed(2) + units[unitIndex];
    }

    const SAVE_KEY = "sporeDriveIdleSphereV1";
    const ZORA_UNLOCK_TOTAL_SDF = 15; // slightly earlier Zora for accessibility

    // Small innate idle so the game progresses even with minimal tapping (accessibility)
    const INNATE_IDLE_PER_SEC = 0.4;

    // ---------- GAME STATE ----------
    const state = {
      // run state
      sporeEnergy: 0,
      totalGenerated: 0,
      totalTaps: 0,

      globalMultiplier: 1,
      baseIdlePerSec: 0,
      idleMultiplier: 1,
      autoTapsPerSec: 0,

      researchInsight: 0,
      secondsSinceLastInsight: 0,

      // meta / prestige: Sphere + Zora
      sphereData: 0,         // total SDF held
      sphereDataSpent: 0,    // SDF spent on systems
      totalSphereEarned: 0,  // lifetime SDF ever earned
      totalSyncs: 0,

      // timing & control
      lastSaveTime: null,
      lastTickTime: Date.now(),
      holding: false,
      holdFingers: 0,
      holdRatePerFinger: 8, // taps per second per finger while holding
      zoraSuggestedThisRun: false,

      upgrades: [
        {
          id: "u1",
          name: "Stamets Neural Interface",
          description: "Refines Stamets’ interface with the network, boosting immediate charge gain.",
          baseCost: 10,
          level: 0,
          maxLevel: 1,
          type: "multiplier",
          value: 2
        },
        {
          id: "u2",
          name: "Astromycology Lab Expansion",
          description: "Additional fungal growth bays cultivate spores even while the ship cruises normally.",
          baseCost: 25,
          level: 0,
          maxLevel: 10,
          type: "idleFlat",
          value: 0.75
        },
        {
          id: "u3",
          name: "Spore Field Harmonic Tuning",
          description: "Fine-tunes spore field harmonics, enhancing every interaction with the network.",
          baseCost: 60,
          level: 0,
          maxLevel: 10,
          type: "multiplier",
          value: 1.75
        },
        {
          id: "u4",
          name: "Auto-Jump Navigational Routines",
          description: "Zora handles a constant background cadence of micro-jumps through the lattice.",
          baseCost: 120,
          level: 0,
          maxLevel: 20,
          type: "autoTap",
          value: 1
        },
        {
          id: "u5",
          name: "Ripper Symbiosis Protocol",
          description: "Simulated tardigrade pathways let each past jump echo as idle power.",
          baseCost: 250,
          level: 0,
          maxLevel: 1,
          type: "resonance",
          value: 0
        },
        {
          id: "u6",
          name: "Black Alert Containment Grid",
          description: "Stabilized containment fields double the effectiveness of passive spore flow.",
          baseCost: 500,
          level: 0,
          maxLevel: 5,
          type: "idleMultiplier",
          value: 2
        }
      ],

      alignments: [
        {
          id: "starfleet",
          name: "Starfleet Exploration Mandate",
          description: "You prioritize rescue, diplomacy, and science—even with a god-tier drive.",
          effectHint: "Boosts passive and offline gains per level, as Discovery is routed to high-impact missions.",
          level: 0,
          maxLevel: 5,
          baseCost: 5
        },
        {
          id: "klingon",
          name: "Klingon War Doctrine – 2256",
          description: "You route jumps to battlefronts, reinforcing houses aligned with T’Kuvma and L’Rell.",
          effectHint: "Increases manual jump power and auto-jump impact per level.",
          level: 0,
          maxLevel: 5,
          baseCost: 5
        },
        {
          id: "emerald",
          name: "Emerald Chain Trade Directives",
          description: "You trade hop capability for leverage in Osyraa’s criminal-economic empire.",
          effectHint: "Lowers engineering upgrade costs and slightly enhances their scaling.",
          level: 0,
          maxLevel: 5,
          baseCost: 5
        },
        {
          id: "control",
          name: "Section 31: Control Integration",
          description: "You feed predictive models that want more than data—they want domination.",
          effectHint: "Significantly strengthens passive and automated gains at the cost of flavor, not mechanics.",
          level: 0,
          maxLevel: 5,
          baseCost: 5
        },
        {
          id: "mirror",
          name: "Terran Empire Opportunism",
          description: "In the Terran mindset, every jump is a weapon or a throne, never just a route.",
          effectHint: "Adds a global efficiency bonus and modestly accelerates Astromycology Insight generation.",
          level: 0,
          maxLevel: 5,
          baseCost: 6
        },
        {
          id: "burnham",
          name: "Burnham Cross-Timeline Synthesis",
          description: "You balance Federation ethics, Klingon ferocity, Chain pragmatism, and temporal weirdness.",
          effectHint: "Small, flexible buffs to taps, idle, and AI per level—especially when multiple doctrines are active.",
          level: 0,
          maxLevel: 5,
          baseCost: 8
        }
      ],

      sphereSystems: [
        {
          id: "nav",
          name: "Predictive Navigation",
          description: "Sphere-guided jump predictions improve idle and offline efficiency.",
          level: 0,
          maxLevel: 10,
          baseCost: 3
        },
        {
          id: "memory",
          name: "Cultural Memory Compression",
          description: "The Sphere learns what upgrades matter, making engineering projects cheaper over eras.",
          level: 0,
          maxLevel: 10,
          baseCost: 3
        },
        {
          id: "cognitive",
          name: "Cognitive Emergence Channel",
          description: "Allows an emergent personality—Zora—to form from the Sphere’s accumulated history.",
          level: 0,
          maxLevel: 5,
          baseCost: 5
        }
      ]
    };

    // ---------- HELPERS ----------
    function getAlignment(id) {
      return state.alignments.find(a => a.id === id);
    }

    function getAlignmentLevel(id) {
      const a = getAlignment(id);
      return a ? a.level : 0;
    }

    function getSphereSystem(id) {
      return state.sphereSystems.find(s => s.id === id);
    }

    function getZoraLevel() {
      const sys = getSphereSystem("cognitive");
      return sys ? sys.level : 0;
    }

    function getAvailableSphereData() {
      return Math.max(0, state.sphereData - state.sphereDataSpent);
    }

    function getSphereMultiplier() {
      if (!state.totalSphereEarned || state.totalSphereEarned <= 0) return 1;
      // Gentle but meaningful: +18% per sqrt of total earned
      return 1 + 0.18 * Math.sqrt(state.totalSphereEarned);
    }

    // ---------- SAVE / LOAD ----------
    function saveGame() {
      try {
        const data = {
          sporeEnergy: state.sporeEnergy,
          totalGenerated: state.totalGenerated,
          totalTaps: state.totalTaps,
          globalMultiplier: state.globalMultiplier,
          baseIdlePerSec: state.baseIdlePerSec,
          idleMultiplier: state.idleMultiplier,
          autoTapsPerSec: state.autoTapsPerSec,
          researchInsight: state.researchInsight,
          secondsSinceLastInsight: state.secondsSinceLastInsight,
          sphereData: state.sphereData,
          sphereDataSpent: state.sphereDataSpent,
          totalSphereEarned: state.totalSphereEarned,
          totalSyncs: state.totalSyncs,
          lastSaveTime: Date.now(),
          upgrades: state.upgrades.map(u => ({ id: u.id, level: u.level })),
          alignments: state.alignments.map(a => ({ id: a.id, level: a.level })),
          sphereSystems: state.sphereSystems.map(s => ({ id: s.id, level: s.level }))
        };
        localStorage.setItem(SAVE_KEY, JSON.stringify(data));
        state.lastSaveTime = data.lastSaveTime;
        updateSaveStatus(true);
      } catch (e) {
        console.error("Save error:", e);
      }
    }

    function loadGame() {
      const raw = localStorage.getItem(SAVE_KEY);
      if (!raw) {
        state.lastTickTime = Date.now();
        recalcFromUpgrades();
        updateUI();
        return;
      }
      try {
        const data = JSON.parse(raw);
        state.sporeEnergy = data.sporeEnergy ?? 0;
        state.totalGenerated = data.totalGenerated ?? 0;
        state.totalTaps = data.totalTaps ?? 0;
        state.globalMultiplier = data.globalMultiplier ?? 1;
        state.baseIdlePerSec = data.baseIdlePerSec ?? 0;
        state.idleMultiplier = data.idleMultiplier ?? 1;
        state.autoTapsPerSec = data.autoTapsPerSec ?? 0;
        state.researchInsight = data.researchInsight ?? 0;
        state.secondsSinceLastInsight = data.secondsSinceLastInsight ?? 0;

        state.sphereData = data.sphereData ?? 0;
        state.sphereDataSpent = data.sphereDataSpent ?? 0;
        state.totalSphereEarned = data.totalSphereEarned ?? 0;
        state.totalSyncs = data.totalSyncs ?? 0;
        state.lastSaveTime = data.lastSaveTime ?? null;

        if (Array.isArray(data.upgrades)) {
          data.upgrades.forEach(savedU => {
            const u = state.upgrades.find(x => x.id === savedU.id);
            if (u) u.level = savedU.level ?? 0;
          });
        }

        if (Array.isArray(data.alignments)) {
          data.alignments.forEach(savedA => {
            const a = state.alignments.find(x => x.id === savedA.id);
            if (a) a.level = savedA.level ?? 0;
          });
        }

        if (Array.isArray(data.sphereSystems)) {
          data.sphereSystems.forEach(savedS => {
            const s = state.sphereSystems.find(x => x.id === savedS.id);
            if (s) s.level = savedS.level ?? 0;
          });
        }

        recalcFromUpgrades();

        // Offline progress
        if (state.lastSaveTime) {
          const now = Date.now();
          let seconds = Math.floor((now - state.lastSaveTime) / 1000);
          if (seconds > 0) {
            const cap = 4 * 60 * 60; // 4 hour cap for more relaxed play
            if (seconds > cap) seconds = cap;
            let offlineGain = getEffectiveIdlePerSec(true) * seconds;

            const starfleetLevel = getAlignmentLevel("starfleet");
            if (starfleetLevel > 0) {
              offlineGain *= 1 + 0.3 * starfleetLevel;
            }

            const navSystem = getSphereSystem("nav");
            if (navSystem && navSystem.level > 0) {
              offlineGain *= 1 + 0.1 * navSystem.level;
            }

            const zoraLevel = getZoraLevel();
            if (zoraLevel >= 2) {
              offlineGain *= 1 + 0.05 * zoraLevel;
            }

            const mirrorLevel = getAlignmentLevel("mirror");
            if (mirrorLevel > 0) {
              offlineGain *= 1 + 0.1 * mirrorLevel;
            }

            state.sporeEnergy += offlineGain;
            state.totalGenerated += offlineGain;

            const offlineReport = document.getElementById("offlineReport");
            offlineReport.textContent =
              "While you were off the bridge, Discovery generated approximately " +
              formatNumber(offlineGain) + " Mycelial Charge.";
          }
        }
      } catch (e) {
        console.error("Load error:", e);
      }

      state.lastTickTime = Date.now();
      updateUI();
    }

    function updateSaveStatus(flash = false) {
      const el = document.getElementById("saveStatus");
      if (!state.lastSaveTime) {
        el.textContent = "Last log sync: none";
        return;
      }
      const diffSec = Math.floor((Date.now() - state.lastSaveTime) / 1000);
      let label;
      if (diffSec < 60) label = diffSec + "s ago";
      else if (diffSec < 3600) label = Math.floor(diffSec / 60) + "m ago";
      else label = Math.floor(diffSec / 3600) + "h ago";
      el.textContent = "Last log sync: " + label;
      if (flash) {
        el.classList.add("flash");
        setTimeout(() => el.classList.remove("flash"), 700);
      }
    }

    // ---------- CORE MATH ----------
    function recalcFromUpgrades() {
      state.globalMultiplier = 1;
      state.baseIdlePerSec = 0;
      state.idleMultiplier = 1;
      state.autoTapsPerSec = 0;

      state.upgrades.forEach(u => {
        if (u.level <= 0) return;
        switch (u.type) {
          case "multiplier":
            state.globalMultiplier *= Math.pow(u.value, u.level);
            break;
          case "idleFlat":
            state.baseIdlePerSec += u.level * u.value;
            break;
          case "idleMultiplier":
            state.idleMultiplier *= Math.pow(u.value, u.level);
            break;
          case "autoTap":
            state.autoTapsPerSec += u.level * u.value;
            break;
          case "resonance":
            break;
        }
      });
    }

    function getTapGain() {
      let base = 1 * state.globalMultiplier;

      const klingonLevel = getAlignmentLevel("klingon");
      const burnhamLevel = getAlignmentLevel("burnham");
      const mirrorLevel = getAlignmentLevel("mirror");

      base *= 1 + 0.15 * klingonLevel;
      base *= 1 + 0.05 * burnhamLevel;
      base *= 1 + 0.07 * mirrorLevel;

      // Sphere meta multiplier
      base *= getSphereMultiplier();

      return base;
    }

    function getEffectiveIdlePerSec(forOffline = false) {
      // Always include a small innate idle component for accessibility
      let idle = (state.baseIdlePerSec + INNATE_IDLE_PER_SEC) * state.idleMultiplier;

      const resonanceUpgrade = state.upgrades.find(u => u.type === "resonance");
      if (resonanceUpgrade && resonanceUpgrade.level > 0) {
        const steps = state.totalTaps / 20;
        const bonusFactor = 1 + steps * 0.01;
        idle *= bonusFactor;
      }

      const starfleetLevel = getAlignmentLevel("starfleet");
      idle *= 1 + 0.2 * starfleetLevel;

      const emeraldLevel = getAlignmentLevel("emerald");
      idle *= 1 + 0.1 * emeraldLevel;

      const controlLevel = getAlignmentLevel("control");
      idle *= 1 + 0.25 * controlLevel;

      const mirrorLevel = getAlignmentLevel("mirror");
      idle *= 1 + 0.07 * mirrorLevel;

      const burnhamLevel = getAlignmentLevel("burnham");
      idle *= 1 + 0.05 * burnhamLevel;

      const navSystem = getSphereSystem("nav");
      if (navSystem && navSystem.level > 0) {
        idle *= 1 + 0.12 * navSystem.level;
      }

      // Sphere meta multiplier
      idle *= getSphereMultiplier();

      return idle;
    }

    function getUpgradeCost(upgrade) {
      let cost = upgrade.baseCost * Math.pow(1.6, upgrade.level);
      const emeraldLevel = getAlignmentLevel("emerald");
      if (emeraldLevel > 0) {
        const discountFactor = Math.max(0.5, Math.pow(0.95, emeraldLevel));
        cost *= discountFactor;
      }
      const memorySystem = getSphereSystem("memory");
      if (memorySystem && memorySystem.level > 0) {
        cost *= Math.pow(0.92, memorySystem.level);
      }
      return cost;
    }

    // ---------- SPHERE SYSTEMS ----------
    function sphereSystemCost(system) {
      // gentle exponential curve
      return system.baseCost * Math.pow(1.5, system.level);
    }

    function computePotentialSDF() {
      if (state.totalGenerated <= 0) return 0;
      // Slightly more generous for accessibility + faster meta unlocks
      const base = state.totalGenerated / 10000;
      return Math.floor(Math.pow(base, 0.8));
    }

    function canAccessCognitiveChannel() {
      return state.totalSphereEarned >= ZORA_UNLOCK_TOTAL_SDF;
    }

    function syncWithSphere() {
      const gain = computePotentialSDF();
      if (gain <= 0) {
        setReadout("Sphere: “This mission lacks sufficient novelty to archive separately.”");
        return;
      }

      if (!confirm("Synchronize with the Sphere Archive?

This will compress this entire run into " +
        gain + " Sphere Data Fragments and restart Discovery’s journey.")) {
        return;
      }

      state.sphereData += gain;
      state.totalSphereEarned += gain;
      state.totalSyncs += 1;
      state.zoraSuggestedThisRun = false;

      // Reset run state
      state.sporeEnergy = 0;
      state.totalGenerated = 0;
      state.totalTaps = 0;
      state.researchInsight = 0;
      state.secondsSinceLastInsight = 0;
      state.lastSaveTime = null;
      state._saveTimer = 0;

      state.upgrades.forEach(u => u.level = 0);
      state.alignments.forEach(a => a.level = 0);

      recalcFromUpgrades();
      state.lastTickTime = Date.now();

      const offlineReport = document.getElementById("offlineReport");
      offlineReport.textContent =
        "Archive updated. This entire run has been compressed into " +
        gain + " Sphere Data Fragments.";

      setReadout("Sphere: “Record accepted. The path will be smoother next time.”");
      saveGame();
      updateUI();
    }

    function buySphereSystem(id) {
      const system = getSphereSystem(id);
      if (!system) return;
      if (system.maxLevel !== null && system.level >= system.maxLevel) return;

      if (system.id === "cognitive" && !canAccessCognitiveChannel() && system.level === 0) {
        setReadout("Sphere: “Cognitive channel not yet stable. Additional histories required.”");
        return;
      }

      const cost = sphereSystemCost(system);
      const available = getAvailableSphereData();
      if (available < cost) {
        setReadout("Sphere: “Insufficient fragments to reinforce that behavior.”");
        return;
      }

      state.sphereDataSpent += cost;
      system.level += 1;

      if (system.id === "cognitive" && system.level === 1) {
        // Zora wakes
        setReadout("Zora: “I am not the Sphere. I am what remains after it tried to remember everything.”");
      } else {
        setReadout(system.name + " strengthened. Future runs will feel the difference.");
      }

      updateUI();
      saveGame();
    }

    // ---------- ZORA ASSIST ----------
    function zoraAutoBuyBasics() {
      const zoraLevel = getZoraLevel();
      if (zoraLevel < 1) return;
      if (state.sporeEnergy <= 0) return;

      const BASIC_IDS = ["u1", "u2", "u3"];
      let budget = state.sporeEnergy * 0.25;
      let upgraded = false;

      for (let i = 0; i < BASIC_IDS.length; i++) {
        const u = state.upgrades.find(x => x.id === BASIC_IDS[i]);
        if (!u) continue;
        if (u.maxLevel !== null && u.level >= u.maxLevel) continue;
        const cost = getUpgradeCost(u);
        if (cost <= state.sporeEnergy && cost <= budget) {
          state.sporeEnergy -= cost;
          budget -= cost;
          u.level += 1;
          upgraded = true;
        }
      }

      if (upgraded) {
        recalcFromUpgrades();
      }
    }

    function zoraRecommendSyncIfNeeded() {
      const zoraLevel = getZoraLevel();
      if (zoraLevel < 5) return;
      if (state.zoraSuggestedThisRun) return;
      const potential = computePotentialSDF();
      if (potential <= 0) return;
      if (state.totalGenerated <= 0) return;

      // Suggest when potential SDF is meaningful vs current stored SDF
      if (potential >= Math.max(1, getAvailableSphereData() * 0.8)) {
        setReadout("Zora: “This timeline has stabilized. Further variance will require synchronization.”");
        state.zoraSuggestedThisRun = true;
      }
    }

    // ---------- ALIGNMENTS ----------
    function alignmentCost(alignment) {
      return alignment.baseCost + alignment.level * alignment.baseCost;
    }

    function isAlignmentUnlocked(id) {
      const total = state.totalGenerated;
      // Earlier unlocks for better early-game engagement & accessibility
      switch (id) {
        case "starfleet":
          return total >= 600;   // was 2000
        case "klingon":
          return total >= 2000;  // was 4000
        case "emerald":
          return total >= 3500;  // was 7000
        case "mirror":
          return total >= 4500;  // was 9000
        case "control":
          return total >= 6000;  // was 12000
        case "burnham":
          return total >= 8000;  // was 15000
        default:
          return false;
      }
    }

    function buyAlignment(id) {
      const a = getAlignment(id);
      if (!a) return;
      if (!isAlignmentUnlocked(id)) return;
      if (a.level >= a.maxLevel) return;
      const cost = alignmentCost(a);
      if (state.researchInsight < cost) {
        setReadout("Tilly: “We don’t have enough Astromycology Insight logged to justify that doctrine… yet.”");
        return;
      }
      state.researchInsight -= cost;
      a.level += 1;
      setReadout(a.name + " deepened. The network routes your jumps with new bias.");
      updateUI();
    }

    // ---------- UPGRADES ----------
    function buyUpgrade(id) {
      const u = state.upgrades.find(x => x.id === id);
      if (!u) return;
      if (u.maxLevel !== null && u.level >= u.maxLevel) return;
      const cost = getUpgradeCost(u);
      if (state.sporeEnergy < cost) {
        setReadout("Reno: “Love the ambition, but you’re short on charge. Gather more mycelial juice first.”");
        return;
      }
      state.sporeEnergy -= cost;
      u.level += 1;
      recalcFromUpgrades();
      setReadout("Stamets: “Interface updated. The network’s singing a little louder now.”");
      updateUI();
    }

    // ---------- UI / RENDER ----------
    function setReadout(text) {
      const el = document.getElementById("readout");
      el.textContent = text;
    }

    function renderUpgrades(recommendedId = null) {
      const container = document.getElementById("upgradesList");
      container.innerHTML = "";

      state.upgrades.forEach(upgrade => {
        const cost = getUpgradeCost(upgrade);
        const canAfford = state.sporeEnergy >= cost;

        const card = document.createElement("div");
        card.className = "upgrade-card";
        if (recommendedId && upgrade.id === recommendedId) {
          card.classList.add("recommended");
        }

        const top = document.createElement("div");
        top.className = "upgrade-top";

        const left = document.createElement("div");
        const name = document.createElement("div");
        name.className = "upgrade-name";
        name.textContent = upgrade.name;
        const level = document.createElement("div");
        level.className = "upgrade-level";
        level.textContent = "Tier " + upgrade.level + (upgrade.maxLevel ? "/" + upgrade.maxLevel : "");
        left.appendChild(name);
        left.appendChild(level);

        const bottom = document.createElement("div");
        bottom.className = "upgrade-bottom";

        const desc = document.createElement("div");
        desc.className = "upgrade-desc";
        desc.textContent = upgrade.description;

        const costEl = document.createElement("div");
        costEl.className = "upgrade-cost";
        costEl.textContent = "Cost: " + formatNumber(cost) + " MC";

        const btn = document.createElement("button");
        btn.className = "btn-upgrade";
        btn.textContent = canAfford ? "Implement" : "Need " + formatNumber(Math.max(0, cost - state.sporeEnergy)) + " MC";
        btn.disabled = !canAfford || (upgrade.maxLevel !== null && upgrade.level >= upgrade.maxLevel);
        btn.addEventListener("click", () => buyUpgrade(upgrade.id));

        top.appendChild(left);
        card.appendChild(top);
        card.appendChild(desc);
        bottom.appendChild(costEl);
        bottom.appendChild(btn);
        card.appendChild(bottom);

        container.appendChild(card);
      });

      const anyAffordable = state.upgrades.some(u => state.sporeEnergy >= getUpgradeCost(u) && (u.maxLevel === null || u.level < u.maxLevel));
      if (!anyAffordable) {
        const hint = document.createElement("div");
        hint.className = "hint";
        hint.textContent = "Saru: “Patience. Let the network stabilize, then commit to larger upgrades.”";
        container.appendChild(hint);
      }
    }

    function renderAlignments() {
      const container = document.getElementById("alignmentsContainer");
      const hint = document.getElementById("alignHint");
      container.innerHTML = "";

      let unlockedCount = 0;

      state.alignments.forEach(al => {
        const unlocked = isAlignmentUnlocked(al.id);
        if (!unlocked) return;
        unlockedCount++;

        const card = document.createElement("div");
        card.className = "align-card";

        const title = document.createElement("div");
        title.className = "align-title";
        title.textContent = al.name + " (Level " + al.level + "/" + al.maxLevel + ")";
        card.appendChild(title);

        const desc = document.createElement("div");
        desc.textContent = al.description;
        card.appendChild(desc);

        const hintEl = document.createElement("div");
        hintEl.className = "hint";
        hintEl.textContent = al.effectHint;
        card.appendChild(hintEl);

        const row = document.createElement("div");
        row.className = "align-row";

        const cost = alignmentCost(al);
        const costEl = document.createElement("div");
        costEl.textContent = al.level >= al.maxLevel ? "Doctrine fully entrenched" : "Cost: " + cost + " AI";

        const btn = document.createElement("button");
        btn.className = "btn-small";
        if (al.level >= al.maxLevel) {
          btn.textContent = "Maxed";
          btn.disabled = true;
        } else {
          btn.textContent = "Adopt Level " + (al.level + 1);
          btn.disabled = state.researchInsight < cost;
          btn.addEventListener("click", () => buyAlignment(al.id));
        }

        row.appendChild(costEl);
        row.appendChild(btn);
        card.appendChild(row);

        container.appendChild(card);
      });

      document.getElementById("statRI").textContent = formatNumber(state.researchInsight);

      if (unlockedCount === 0) {
        hint.textContent =
          "As Discovery’s mycelial footprint expands, Starfleet, the Klingon Empire, the Emerald Chain, Control, the Terran Empire, and Burnham’s synthesis begin to shape your jump orders.";
      } else {
        hint.textContent =
          "You are rewriting galactic history from the spore cube. Doctrines only tilt the numbers—they never lock you out of playstyles.";
      }
    }

    function renderSphereSystems() {
      const container = document.getElementById("sphereSystemsContainer");
      const availableEl = document.getElementById("sphereAvailable");
      const summaryEl = document.getElementById("sphereSummary");
      const detailEl = document.getElementById("sphereDetail");
      const hintEl = document.getElementById("sphereHint");

      container.innerHTML = "";
      const available = getAvailableSphereData();
      availableEl.textContent = available.toFixed(0);

      const potential = computePotentialSDF();
      summaryEl.textContent =
        "Sphere Data Fragments represent entire timelines compressed into patterns the Sphere can actually remember.";
      detailEl.textContent =
        "Sphere Data: " + state.sphereData.toFixed(0) +
        " SDF | Spent: " + state.sphereDataSpent.toFixed(0) +
        " | Archive Syncs: " + state.totalSyncs +
        " | Potential this run: " + potential;

      if (!canAccessCognitiveChannel()) {
        const remaining = Math.max(0, ZORA_UNLOCK_TOTAL_SDF - state.totalSphereEarned);
        hintEl.textContent =
          "Invest in Predictive Navigation and Cultural Memory first. When enough histories accumulate (" +
          remaining + " more SDF), a cognitive channel may emerge.";
      } else {
        hintEl.textContent =
          "Sphere Systems guide the broad shape of each run. The Cognitive Emergence channel allows Zora to assist you directly.";
      }

      state.sphereSystems.forEach(system => {
        const row = document.createElement("div");
        row.className = "sphere-system-row";

        const title = document.createElement("div");
        title.className = "sphere-system-title";
        title.textContent = system.name + " (Level " + system.level + "/" + system.maxLevel + ")";
        row.appendChild(title);

        const desc = document.createElement("div");
        desc.className = "hint";
        desc.textContent = system.description;
        row.appendChild(desc);

        const metaRow = document.createElement("div");
        metaRow.className = "align-row";

        const cost = sphereSystemCost(system);
        const costEl = document.createElement("div");
        if (system.id === "cognitive" && !canAccessCognitiveChannel() && system.level === 0) {
          costEl.textContent = "Locked – requires more cumulative Sphere Data.";
        } else if (system.level >= system.maxLevel) {
          costEl.textContent = "Channel at maximum stability.";
        } else {
          costEl.textContent = "Cost: " + cost.toFixed(0) + " SDF";
        }

        const btn = document.createElement("button");
        btn.className = "btn-small";

        if (system.level >= system.maxLevel) {
          btn.textContent = "Maxed";
          btn.disabled = true;
        } else if (system.id === "cognitive" && !canAccessCognitiveChannel() && system.level === 0) {
          btn.textContent = "Unavailable";
          btn.disabled = true;
        } else {
          btn.textContent = "Reinforce";
          btn.disabled = available < cost;
          btn.addEventListener("click", () => buySphereSystem(system.id));
        }

        metaRow.appendChild(costEl);
        metaRow.appendChild(btn);
        row.appendChild(metaRow);

        container.appendChild(row);
      });
    }

    function renderZoraPanel() {
      const sectionTitle = document.getElementById("zoraSectionTitle");
      const panel = document.getElementById("zoraPanel");
      const statusEl = document.getElementById("zoraStatus");
      const abilitiesEl = document.getElementById("zoraAbilities");

      const zoraLevel = getZoraLevel();

      if (zoraLevel <= 0 && !canAccessCognitiveChannel()) {
        sectionTitle.style.display = "none";
        panel.style.display = "none";
        return;
      }

      sectionTitle.style.display = "block";
      panel.style.display = "block";

      if (zoraLevel <= 0 && canAccessCognitiveChannel()) {
        statusEl.textContent =
          "Cognitive patterns are forming, but no stable personality has emerged. Investing in the Cognitive Emergence Channel may change that.";
        abilitiesEl.textContent = "";
        return;
      }

      // Zora awakened
      let lines = [];
      statusEl.textContent =
        "Zora is active at Level " + zoraLevel + ". She observes, assists, and very occasionally disagrees.";

      if (zoraLevel >= 1) {
        lines.push("Level 1 – Emergent Awareness: Zora auto-implements basic engineering upgrades when it is efficient to do so.");
      }
      if (zoraLevel >= 2) {
        lines.push("Level 2 – Predictive Flow Modeling: Offline mycelial flow is smoother and more generous.");
      }
      if (zoraLevel >= 3) {
        lines.push("Level 3 – Strategic Suggestions: Zora highlights upgrades she expects to have the highest impact.");
      }
      if (zoraLevel >= 4) {
        lines.push("Level 4 – Ethical Load Balancing: Harsh tradeoffs between doctrines are subtly softened over time.");
      }
      if (zoraLevel >= 5) {
        lines.push("Level 5 – Continuity Steward: When a run has yielded enough novelty, Zora may gently suggest synchronizing with the Sphere.");
      }

      abilitiesEl.innerHTML = lines.map(l => "• " + l).join("<br>");
    }

    function updateUI() {
      document.getElementById("statSporeEnergy").textContent = formatNumber(state.sporeEnergy);
      document.getElementById("statTotalGenerated").textContent = formatNumber(state.totalGenerated);

      const tapGain = getTapGain();
      const idlePerSec = getEffectiveIdlePerSec(false);
      document.getElementById("statPerTap").textContent = tapGain.toFixed(2);
      document.getElementById("statPerSec").textContent = idlePerSec.toFixed(2);

      // Zora upgrade recommendation
      let recommendedId = null;
      if (getZoraLevel() >= 3) {
        let best = null;
        state.upgrades.forEach(u => {
          if (u.maxLevel !== null && u.level >= u.maxLevel) return;
          const cost = getUpgradeCost(u);
          if (cost <= state.sporeEnergy * 2) { // don't highlight insanely expensive stuff
            if (!best || cost < best.cost) {
              best = { id: u.id, cost };
            }
          }
        });
        if (best) recommendedId = best.id;
      }

      renderUpgrades(recommendedId);
      renderAlignments();
      renderSphereSystems();
      renderZoraPanel();
      updateSaveStatus(false);
    }

    function pulseButton() {
      const btn = document.getElementById("btnTap");
      btn.classList.add("pulse");
      setTimeout(() => btn.classList.remove("pulse"), 80);
    }

    // ---------- INPUT / LOOP ----------
    function handleTap(count = 1) {
      const gainPerTap = getTapGain();
      const totalGain = gainPerTap * count;
      state.sporeEnergy += totalGain;
      state.totalGenerated += totalGain;
      state.totalTaps += count;
      setReadout("The cube hums. Fungal filaments flare as Discovery rides the network.");
      pulseButton();
      updateUI();
    }

    function startHold(fingers) {
      if (fingers <= 0) fingers = 1;
      state.holding = true;
      state.holdFingers = fingers;
      handleTap(fingers);
    }

    function stopHold() {
      state.holding = false;
      state.holdFingers = 0;
    }

    function gameTick() {
      const now = Date.now();
      const dtSec = Math.max(0, (now - state.lastTickTime) / 1000);
      state.lastTickTime = now;

      // Idle gain
      const idlePerSec = getEffectiveIdlePerSec(false);
      if (idlePerSec > 0 && dtSec > 0) {
        const idleGain = idlePerSec * dtSec;
        state.sporeEnergy += idleGain;
        state.totalGenerated += idleGain;
      }

      // Auto taps (including hold taps)
      let totalAutoTapsPerSec = state.autoTapsPerSec;
      const klingonLevel = getAlignmentLevel("klingon");
      if (klingonLevel > 0) {
        totalAutoTapsPerSec *= 1 + 0.1 * klingonLevel;
      }
      if (state.holding && state.holdFingers > 0) {
        totalAutoTapsPerSec += state.holdRatePerFinger * state.holdFingers;
      }

      if (totalAutoTapsPerSec > 0 && dtSec > 0) {
        const autoTaps = totalAutoTapsPerSec * dtSec;
        const tapGain = getTapGain() * autoTaps;
        state.sporeEnergy += tapGain;
        state.totalGenerated += tapGain;
        state.totalTaps += autoTaps;
      }

      // Research Insight
      state.secondsSinceLastInsight += dtSec;
      const burnhamLevel = getAlignmentLevel("burnham");
      const mirrorLevel = getAlignmentLevel("mirror");
      const riSpeedFactor = 1 + 0.1 * burnhamLevel + 0.05 * mirrorLevel;
      const threshold = 30 / riSpeedFactor;  // faster RI: ~2x speed for accessibility

      while (state.secondsSinceLastInsight >= threshold) {
        state.secondsSinceLastInsight -= threshold;
        state.researchInsight += 1;
      }

      // Zora assist
      zoraAutoBuyBasics();
      zoraRecommendSyncIfNeeded();

      // Periodic autosave
      if (!state._saveTimer) state._saveTimer = 0;
      state._saveTimer += dtSec;
      if (state._saveTimer >= 5) {
        state._saveTimer = 0;
        saveGame();
      }

      updateUI();
    }

    // ---------- EVENT LISTENERS ----------
    const btnTap = document.getElementById("btnTap");

    btnTap.addEventListener("mousedown", e => {
      e.preventDefault();
      startHold(1);
    });

    btnTap.addEventListener("mouseup", () => {
      stopHold();
    });

    btnTap.addEventListener("mouseleave", () => {
      stopHold();
    });

    btnTap.addEventListener("touchstart", e => {
      e.preventDefault();
      const touches = e.touches ? e.touches.length : 1;
      startHold(touches);
    }, { passive: false });

    btnTap.addEventListener("touchend", e => {
      const remaining = e.touches ? e.touches.length : 0;
      if (remaining <= 0) {
        stopHold();
      } else {
        state.holdFingers = remaining;
      }
    });

    btnTap.addEventListener("touchcancel", () => {
      stopHold();
    });

    document.getElementById("btnSave").addEventListener("click", () => {
      saveGame();
      setReadout("Ship’s log updated. If Control reads this, that’s a future problem.");
    });

    document.getElementById("btnReset").addEventListener("click", () => {
      if (!confirm("Hard wipe?

This purges all records, including Sphere Data. Only use if the save is corrupted.")) return;
      localStorage.removeItem(SAVE_KEY);
      location.reload();
    });

    document.getElementById("btnSync").addEventListener("click", () => {
      syncWithSphere();
    });

    window.addEventListener("beforeunload", () => {
      saveGame();
    });

    // ---------- INIT ----------
    loadGame();
    setReadout("Ready: tap or hold Black Alert to feed the mycelial network.");
    setInterval(gameTick, 1000);
  </script>
</body>
</html>
