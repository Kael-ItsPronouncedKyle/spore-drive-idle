<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Spore Drive Idle</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      background: radial-gradient(circle at top, #1b2a3a 0%, #05060a 60%, #020308 100%);
      color: #e5f2ff;
      min-height: 100vh;
      display: flex;
      justify-content: center;
    }

    .app {
      width: 100%;
      max-width: 480px;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    header {
      text-align: center;
    }

    header h1 {
      font-size: 1.5rem;
      letter-spacing: 0.05em;
      margin-bottom: 0.15rem;
    }

    header p {
      font-size: 0.85rem;
      opacity: 0.85;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 0.5rem;
      margin-top: 0.6rem;
    }

    .card {
      background: rgba(8, 16, 30, 0.95);
      border-radius: 0.7rem;
      padding: 0.55rem 0.7rem;
      border: 1px solid rgba(120, 180, 255, 0.3);
    }

    .stat-label {
      font-size: 0.78rem;
      opacity: 0.75;
    }

    .stat-value {
      font-size: 1rem;
      margin-top: 0.1rem;
    }

    .main-button-wrapper {
      margin-top: 0.7rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.15rem;
    }

    .main-button {
      width: 100%;
      max-width: 360px;
      padding: 1rem;
      border-radius: 999px;
      border: none;
      font-size: 1.1rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      background: linear-gradient(135deg, #3bb2ff, #78ffce);
      color: #02111e;
      box-shadow: 0 0.4rem 1rem rgba(0, 0, 0, 0.6);
      touch-action: manipulation;
      transition: transform 0.08s ease, box-shadow 0.08s ease;
    }

    .main-button:active,
    .main-button.pulse {
      transform: scale(0.96);
      box-shadow: 0 0.25rem 0.7rem rgba(0, 0, 0, 0.9);
    }

    .small-text {
      font-size: 0.78rem;
      opacity: 0.9;
      text-align: center;
    }

    .readout {
      min-height: 1.1rem;
      font-size: 0.83rem;
      text-align: center;
      opacity: 0.95;
      margin-top: 0.25rem;
    }

    .section-title {
      font-size: 0.92rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      opacity: 0.8;
      margin-top: 0.7rem;
      padding-bottom: 0.25rem;
      border-bottom: 1px solid rgba(120, 180, 255, 0.4);
    }

    .upgrades-list {
      max-height: 260px;
      overflow-y: auto;
      margin-top: 0.4rem;
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
      padding-right: 0.2rem;
    }

    .upgrade-card {
      background: rgba(5, 12, 26, 0.96);
      border-radius: 0.6rem;
      padding: 0.55rem 0.6rem;
      border: 1px solid rgba(80, 130, 210, 0.5);
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
      font-size: 0.8rem;
    }

    .upgrade-top {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 0.4rem;
    }

    .upgrade-name {
      font-weight: 600;
      font-size: 0.86rem;
    }

    .upgrade-level {
      font-size: 0.76rem;
      opacity: 0.7;
    }

    .upgrade-desc {
      opacity: 0.9;
    }

    .upgrade-bottom {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.6rem;
    }

    .upgrade-cost {
      font-size: 0.78rem;
      opacity: 0.9;
    }

    .btn-upgrade {
      padding: 0.25rem 0.65rem;
      border-radius: 999px;
      border: none;
      font-size: 0.78rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      background: linear-gradient(135deg, #1b8cff, #48ffd2);
      color: #020c14;
      touch-action: manipulation;
    }

    .btn-upgrade:disabled {
      background: rgba(70, 90, 120, 0.9);
      color: rgba(215, 225, 245, 0.7);
    }

    .save-row {
      margin-top: 0.5rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.76rem;
    }

    .btn-small {
      padding: 0.25rem 0.65rem;
      border-radius: 999px;
      border: 1px solid rgba(120, 180, 255, 0.6);
      background: rgba(5, 12, 22, 0.95);
      color: #e5f2ff;
      font-size: 0.74rem;
      touch-action: manipulation;
    }

    .save-status.flash {
      color: #78ffce;
    }

    .alignments {
      margin-top: 0.35rem;
      font-size: 0.78rem;
    }

    .align-card {
      background: rgba(10, 18, 35, 0.98);
      border-radius: 0.6rem;
      padding: 0.55rem 0.6rem;
      border: 1px solid rgba(160, 130, 255, 0.7);
      margin-top: 0.35rem;
    }

    .align-title {
      font-size: 0.84rem;
      font-weight: 600;
      margin-bottom: 0.15rem;
    }

    .align-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 0.3rem;
      gap: 0.5rem;
    }

    .hint {
      font-size: 0.75rem;
      opacity: 0.8;
      margin-top: 0.15rem;
    }

    footer {
      font-size: 0.68rem;
      text-align: center;
      opacity: 0.6;
      margin-top: 0.4rem;
    }

    .surge-indicator {
      font-size: 0.78rem;
      text-align: center;
      margin-top: 0.2rem;
      color: #ffe680;
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Spore Drive Idle</h1>
      <p>Tap to feed the mycelial network. Let the ship work while you rest.</p>

      <div class="stats-grid">
        <div class="card">
          <div class="stat-label">Spore Energy</div>
          <div class="stat-value" id="statSporeEnergy">0</div>
        </div>
        <div class="card">
          <div class="stat-label">Gain Rate</div>
          <div class="stat-value">
            <span id="statPerTap">1</span> / tap<br />
            <span id="statPerSec">0</span> / sec
          </div>
        </div>
        <div class="card">
          <div class="stat-label">Total Generated</div>
          <div class="stat-value" id="statTotalGenerated">0</div>
        </div>
        <div class="card">
          <div class="stat-label">Research Insight</div>
          <div class="stat-value" id="statRI">0</div>
        </div>
      </div>
    </header>

    <div class="main-button-wrapper">
      <button id="btnTap" class="main-button">Engage Spore Jump</button>
      <div class="small-text">Tip: use multiple fingers at once for faster jumps.</div>
      <div class="surge-indicator" id="surgeIndicator"></div>
    </div>

    <div class="readout" id="readout">
      First order: tap Engage Spore Jump to begin generating spore energy.
    </div>

    <div class="section-title">Upgrades</div>
    <div class="upgrades-list" id="upgradesList"></div>

    <div class="section-title">Command Data</div>
    <div class="card">
      <div class="save-row">
        <div class="save-status" id="saveStatus">Last save: none</div>
        <div>
          <button class="btn-small" id="btnSave">Save now</button>
          <button class="btn-small" id="btnReset">Reset</button>
        </div>
      </div>
      <div class="hint" id="offlineReport"></div>
    </div>

    <div class="section-title">Advanced Systems</div>
    <div class="alignments">
      <div class="hint" id="alignHint">
        Experimental doctrines unlock as the ship gathers experience.
      </div>
      <div class="align-card" id="ndaCard" style="display:none;">
        <div class="align-title">Non-Deterministic Allowance (Level <span id="ndaLevel">0</span>/3)</div>
        <div>Allows beneficial unpredictability in spore gain and offline reconstruction.</div>
        <div class="hint">
          Effect: small positive randomness on idle/offline gains. Higher levels increase surge frequency and strength.
        </div>
        <div class="align-row">
          <div>Cost: <span id="ndaCost">3</span> Research Insight</div>
          <button class="btn-small" id="btnBuyNDA">Upgrade</button>
        </div>
      </div>
    </div>

    <footer>
      Fan-made idle experiment. Progress is the real canon.
    </footer>
  </div>

  <script>
    // ---------- UTILITIES ----------
    function formatNumber(n) {
      if (!isFinite(n)) return "0";
      if (n < 1000) return n.toFixed(0);
      const units = ["K", "M", "B", "T", "Q"];
      let unitIndex = -1;
      let value = n;
      while (value >= 1000 && unitIndex < units.length - 1) {
        value /= 1000;
        unitIndex++;
      }
      return value.toFixed(2) + units[unitIndex];
    }

    // ---------- GAME STATE ----------
    const SAVE_KEY = "sporeDriveIdleSaveV1";

    const state = {
      sporeEnergy: 0,
      totalGenerated: 0,
      totalTaps: 0,

      globalMultiplier: 1,      // affects taps + idle
      baseIdlePerSec: 0,        // from upgrades
      idleMultiplier: 1,        // from upgrades
      autoTapsPerSec: 0,        // from upgrades

      researchInsight: 0,
      secondsSinceLastInsight: 0,

      ndaLevel: 0,              // Non-Deterministic Allowance level (0-3)
      ndaUnlocked: false,

      lastSaveTime: null,
      lastTickTime: Date.now(),

      surgeActive: false,
      surgeEndsAt: 0,

      upgrades: [
        {
          id: "u1",
          name: "Spore Conduit Calibration",
          description: "Re-align conduits for a clean burst in output.",
          baseCost: 10,
          level: 0,
          maxLevel: 1,          // one-time power spike
          type: "multiplier",
          value: 2
        },
        {
          id: "u2",
          name: "Auxiliary Fungal Arrays",
          description: "Dedicated growth bays generate passive spore energy.",
          baseCost: 25,
          level: 0,
          maxLevel: 10,
          type: "idleFlat",
          value: 0.75
        },
        {
          id: "u3",
          name: "Field Harmonic Tuning",
          description: "Fine-tune drive harmonics to boost all gains.",
          baseCost: 60,
          level: 0,
          maxLevel: 10,
          type: "multiplier",
          value: 1.75
        },
        {
          id: "u4",
          name: "Automated Jump Subroutines",
          description: "Computer-controlled micro-jumps add taps every second.",
          baseCost: 120,
          level: 0,
          maxLevel: 20,
          type: "autoTap",
          value: 1
        },
        {
          id: "u5",
          name: "Mycelial Resonance Loop",
          description: "Idle gains scale with all taps you've ever made.",
          baseCost: 250,
          level: 0,
          maxLevel: 1,
          type: "resonance",
          value: 0 // value unused, just flag
        },
        {
          id: "u6",
          name: "Spore Field Amplifier",
          description: "Dedicated amplifiers double passive mycelial flow.",
          baseCost: 500,
          level: 0,
          maxLevel: 5,
          type: "idleMultiplier",
          value: 2
        }
      ]
    };

    // ---------- SAVE / LOAD ----------
    function saveGame() {
      try {
        const data = {
          sporeEnergy: state.sporeEnergy,
          totalGenerated: state.totalGenerated,
          totalTaps: state.totalTaps,
          globalMultiplier: state.globalMultiplier,
          baseIdlePerSec: state.baseIdlePerSec,
          idleMultiplier: state.idleMultiplier,
          autoTapsPerSec: state.autoTapsPerSec,
          researchInsight: state.researchInsight,
          ndaLevel: state.ndaLevel,
          ndaUnlocked: state.ndaUnlocked,
          lastSaveTime: Date.now(),
          surgeActive: state.surgeActive,
          surgeEndsAt: state.surgeEndsAt,
          upgrades: state.upgrades.map(u => ({ id: u.id, level: u.level })),
        };
        localStorage.setItem(SAVE_KEY, JSON.stringify(data));
        state.lastSaveTime = data.lastSaveTime;
        updateSaveStatus(true);
      } catch (e) {
        console.error("Save error:", e);
      }
    }

    function loadGame() {
      const raw = localStorage.getItem(SAVE_KEY);
      if (!raw) {
        state.lastTickTime = Date.now();
        recalcFromUpgrades();
        updateUI();
        return;
      }
      try {
        const data = JSON.parse(raw);
        state.sporeEnergy = data.sporeEnergy ?? 0;
        state.totalGenerated = data.totalGenerated ?? 0;
        state.totalTaps = data.totalTaps ?? 0;
        state.globalMultiplier = data.globalMultiplier ?? 1;
        state.baseIdlePerSec = data.baseIdlePerSec ?? 0;
        state.idleMultiplier = data.idleMultiplier ?? 1;
        state.autoTapsPerSec = data.autoTapsPerSec ?? 0;
        state.researchInsight = data.researchInsight ?? 0;
        state.ndaLevel = data.ndaLevel ?? 0;
        state.ndaUnlocked = data.ndaUnlocked ?? false;
        state.surgeActive = data.surgeActive ?? false;
        state.surgeEndsAt = data.surgeEndsAt ?? 0;
        state.lastSaveTime = data.lastSaveTime ?? null;

        if (Array.isArray(data.upgrades)) {
          data.upgrades.forEach(savedU => {
            const u = state.upgrades.find(x => x.id === savedU.id);
            if (u) u.level = savedU.level ?? 0;
          });
        }

        // Recalculate from upgrade levels
        recalcFromUpgrades();

        // Apply offline progress
        if (state.lastSaveTime) {
          const now = Date.now();
          let seconds = Math.floor((now - state.lastSaveTime) / 1000);
          if (seconds > 0) {
            const cap = 2 * 60 * 60; // 2 hours cap
            if (seconds > cap) seconds = cap;
            let offlineGain = getEffectiveIdlePerSec() * seconds;

            // If NDA is active, add a small positive bias
            if (state.ndaLevel >= 1) {
              const biasMax = 0.4; // up to +40%
              const factor = 1 + Math.random() * biasMax;
              offlineGain *= factor;
            }

            state.sporeEnergy += offlineGain;
            state.totalGenerated += offlineGain;

            const offlineReport = document.getElementById("offlineReport");
            offlineReport.textContent =
              "While you were away, the ship generated approximately " +
              formatNumber(offlineGain) + " spore energy.";
          }
        }
      } catch (e) {
        console.error("Load error:", e);
      }

      state.lastTickTime = Date.now();
      updateUI();
    }

    function updateSaveStatus(flash = false) {
      const el = document.getElementById("saveStatus");
      if (!state.lastSaveTime) {
        el.textContent = "Last save: none";
        return;
      }
      const diffSec = Math.floor((Date.now() - state.lastSaveTime) / 1000);
      let label;
      if (diffSec < 60) label = diffSec + "s ago";
      else if (diffSec < 3600) label = Math.floor(diffSec / 60) + "m ago";
      else label = Math.floor(diffSec / 3600) + "h ago";
      el.textContent = "Last save: " + label;
      if (flash) {
        el.classList.add("flash");
        setTimeout(() => el.classList.remove("flash"), 700);
      }
    }

    // ---------- UPGRADES / MATH ----------
    function recalcFromUpgrades() {
      state.globalMultiplier = 1;
      state.baseIdlePerSec = 0;
      state.idleMultiplier = 1;
      state.autoTapsPerSec = 0;

      state.upgrades.forEach(u => {
        if (u.level <= 0) return;
        switch (u.type) {
          case "multiplier":
            state.globalMultiplier *= Math.pow(u.value, u.level);
            break;
          case "idleFlat":
            state.baseIdlePerSec += u.level * u.value;
            break;
          case "idleMultiplier":
            state.idleMultiplier *= Math.pow(u.value, u.level);
            break;
          case "autoTap":
            state.autoTapsPerSec += u.level * u.value;
            break;
          case "resonance":
            // handled dynamically in getEffectiveIdlePerSec
            break;
        }
      });
    }

    function getTapGain() {
      return 1 * state.globalMultiplier;
    }

    function getEffectiveIdlePerSec() {
      let idle = state.baseIdlePerSec * state.idleMultiplier;
      // Resonance: +1% per 20 total taps if upgrade is active
      const resonanceUpgrade = state.upgrades.find(u => u.type === "resonance");
      if (resonanceUpgrade && resonanceUpgrade.level > 0) {
        const steps = state.totalTaps / 20;
        const bonusFactor = 1 + steps * 0.01;
        idle *= bonusFactor;
      }
      // Surge bonus if active
      if (state.surgeActive) {
        idle *= 2; // surge doubles idle for its duration
      }
      return idle;
    }

    function getUpgradeCost(upgrade) {
      // Simple cost ramp: cost * (1.6 ^ level)
      return upgrade.baseCost * Math.pow(1.6, upgrade.level);
    }

    function buyUpgrade(id) {
      const u = state.upgrades.find(x => x.id === id);
      if (!u) return;
      if (u.maxLevel !== null && u.level >= u.maxLevel) return;
      const cost = getUpgradeCost(u);
      if (state.sporeEnergy < cost) {
        setReadout("Engineering reports insufficient spore energy for that upgrade.");
        return;
      }
      state.sporeEnergy -= cost;
      u.level += 1;
      recalcFromUpgrades();
      setReadout("Upgrade installed. Systems report improved flow across the lattice.");
      updateUI();
    }

    // ---------- ALIGNMENT: NON-DETERMINISTIC ALLOWANCE ----------
    function ndaCostForNextLevel() {
      const base = 3;
      return base + state.ndaLevel * 3; // 3, 6, 9
    }

    function maybeUnlockNDA() {
      if (state.ndaUnlocked) return;
      if (state.totalGenerated >= 2000) {
        state.ndaUnlocked = true;
      }
    }

    function buyNDA() {
      const maxLevel = 3;
      if (!state.ndaUnlocked) return;
      if (state.ndaLevel >= maxLevel) return;
      const cost = ndaCostForNextLevel();
      if (state.researchInsight < cost) {
        setReadout("You lack sufficient Research Insight for that experimental protocol.");
        return;
      }
      state.researchInsight -= cost;
      state.ndaLevel += 1;
      setReadout("Non-Deterministic Allowance expanded. The network grows more playful.");
      updateUI();
    }

    function maybeStartSurge() {
      if (state.ndaLevel < 2) return;
      if (state.surgeActive) return;
      // Every tick we roll a small chance of surge
      const chancePerSecond = state.ndaLevel === 2 ? 0.02 : 0.04; // 2% or 4% per second
      if (Math.random() < chancePerSecond) {
        const now = Date.now();
        const duration = 15000 + Math.random() * 15000; // 15-30 sec
        state.surgeActive = true;
        state.surgeEndsAt = now + duration;
        const indicator = document.getElementById("surgeIndicator");
        indicator.textContent = "Spore Surge active: gains temporarily increased!";
      }
    }

    function checkSurgeEnd() {
      if (!state.surgeActive) return;
      const now = Date.now();
      if (now >= state.surgeEndsAt) {
        state.surgeActive = false;
        state.surgeEndsAt = 0;
        const indicator = document.getElementById("surgeIndicator");
        indicator.textContent = "";
      }
    }

    // ---------- UI / READOUT ----------
    function setReadout(text) {
      const el = document.getElementById("readout");
      el.textContent = text;
    }

    function renderUpgrades() {
      const container = document.getElementById("upgradesList");
      container.innerHTML = "";

      state.upgrades.forEach(upgrade => {
        const cost = getUpgradeCost(upgrade);
        const canAfford = state.sporeEnergy >= cost;
        const card = document.createElement("div");
        card.className = "upgrade-card";

        const top = document.createElement("div");
        top.className = "upgrade-top";

        const left = document.createElement("div");
        const name = document.createElement("div");
        name.className = "upgrade-name";
        name.textContent = upgrade.name;
        const level = document.createElement("div");
        level.className = "upgrade-level";
        level.textContent = "Level " + upgrade.level + (upgrade.maxLevel ? "/" + upgrade.maxLevel : "");
        left.appendChild(name);
        left.appendChild(level);

        const bottom = document.createElement("div");
        bottom.className = "upgrade-bottom";

        const desc = document.createElement("div");
        desc.className = "upgrade-desc";
        desc.textContent = upgrade.description;

        const costEl = document.createElement("div");
        costEl.className = "upgrade-cost";
        costEl.textContent = "Cost: " + formatNumber(cost) + " SE";

        const btn = document.createElement("button");
        btn.className = "btn-upgrade";
        btn.textContent = canAfford ? "Install" : "Need " + formatNumber(cost - state.sporeEnergy);
        btn.disabled = !canAfford || (upgrade.maxLevel !== null && upgrade.level >= upgrade.maxLevel);
        btn.addEventListener("click", () => buyUpgrade(upgrade.id));

        top.appendChild(left);
        card.appendChild(top);
        card.appendChild(desc);
        bottom.appendChild(costEl);
        bottom.appendChild(btn);
        card.appendChild(bottom);

        container.appendChild(card);
      });

      // Tiny hint if nothing affordable
      const anyAffordable = state.upgrades.some(u => state.sporeEnergy >= getUpgradeCost(u) && (u.maxLevel === null || u.level < u.maxLevel));
      if (!anyAffordable) {
        const hint = document.createElement("div");
        hint.className = "hint";
        hint.textContent = "Recommendation: push a few more taps, then invest in Auxiliary Fungal Arrays for steady idle gain.";
        container.appendChild(hint);
      }
    }

    function updateAlignmentUI() {
      maybeUnlockNDA();

      const card = document.getElementById("ndaCard");
      const hint = document.getElementById("alignHint");
      const levelEl = document.getElementById("ndaLevel");
      const costEl = document.getElementById("ndaCost");
      const btn = document.getElementById("btnBuyNDA");

      document.getElementById("statRI").textContent = formatNumber(state.researchInsight);

      if (!state.ndaUnlocked) {
        card.style.display = "none";
        hint.textContent = "Experimental doctrines unlock once enough spore energy has flowed through the drive.";
        return;
      }

      card.style.display = "block";
      hint.textContent = "Alignment upgrades are optional. They change how the universe treats your progress, not whether you progress.";

      const maxLevel = 3;
      levelEl.textContent = state.ndaLevel;
      if (state.ndaLevel >= maxLevel) {
        costEl.textContent = "MAX";
        btn.disabled = true;
        btn.textContent = "Maxed";
      } else {
        const cost = ndaCostForNextLevel();
        costEl.textContent = cost;
        btn.disabled = state.researchInsight < cost;
        btn.textContent = "Upgrade";
      }
    }

    function updateUI() {
      // Stats
      document.getElementById("statSporeEnergy").textContent = formatNumber(state.sporeEnergy);
      document.getElementById("statTotalGenerated").textContent = formatNumber(state.totalGenerated);

      const tapGain = getTapGain();
      const idlePerSec = getEffectiveIdlePerSec();

      document.getElementById("statPerTap").textContent = tapGain.toFixed(2);
      document.getElementById("statPerSec").textContent = idlePerSec.toFixed(2);

      renderUpgrades();
      updateAlignmentUI();
      updateSaveStatus(false);
    }

    function pulseButton() {
      const btn = document.getElementById("btnTap");
      btn.classList.add("pulse");
      setTimeout(() => btn.classList.remove("pulse"), 80);
    }

    // ---------- INPUT / LOOP ----------
    function handleTap(count = 1) {
      const gainPerTap = getTapGain();
      const totalGain = gainPerTap * count;
      state.sporeEnergy += totalGain;
      state.totalGenerated += totalGain;
      state.totalTaps += count;
      setReadout("Spore chamber surges with energy. Network threads brighten.");
      pulseButton();
      updateUI();
    }

    function gameTick() {
      const now = Date.now();
      const dtSec = Math.max(0, (now - state.lastTickTime) / 1000);
      state.lastTickTime = now;

      // Idle gain
      const idlePerSec = getEffectiveIdlePerSec();
      if (idlePerSec > 0 && dtSec > 0) {
        const idleGain = idlePerSec * dtSec;
        state.sporeEnergy += idleGain;
        state.totalGenerated += idleGain;
      }

      // Auto taps (count as taps)
      if (state.autoTapsPerSec > 0 && dtSec > 0) {
        const autoTaps = state.autoTapsPerSec * dtSec;
        const tapGain = getTapGain() * autoTaps;
        state.sporeEnergy += tapGain;
        state.totalGenerated += tapGain;
        state.totalTaps += autoTaps;
      }

      // Research Insight over time (1 RI per 60s of play/idle)
      state.secondsSinceLastInsight += dtSec;
      while (state.secondsSinceLastInsight >= 60) {
        state.secondsSinceLastInsight -= 60;
        state.researchInsight += 1;
      }

      // Alignment behaviors
      maybeStartSurge();
      checkSurgeEnd();

      // Occasional auto-save
      if (!state._saveTimer) state._saveTimer = 0;
      state._saveTimer += dtSec;
      if (state._saveTimer >= 5) {
        state._saveTimer = 0;
        saveGame();
      }

      updateUI();
    }

    // ---------- EVENT LISTENERS ----------
    document.getElementById("btnTap").addEventListener("click", () => {
      handleTap(1);
    });

    // Multi-touch on mobile
    document.getElementById("btnTap").addEventListener("touchstart", e => {
      e.preventDefault();
      const touches = e.touches ? e.touches.length : 1;
      handleTap(touches);
    }, { passive: false });

    document.getElementById("btnSave").addEventListener("click", () => {
      saveGame();
      setReadout("Command log saved to encrypted buffer.");
    });

    document.getElementById("btnReset").addEventListener("click", () => {
      if (!confirm("Reset all progress and clear local save?")) return;
      localStorage.removeItem(SAVE_KEY);
      location.reload();
    });

    document.getElementById("btnBuyNDA").addEventListener("click", () => {
      buyNDA();
    });

    window.addEventListener("beforeunload", () => {
      saveGame();
    });

    // ---------- INIT ----------
    loadGame();
    setInterval(gameTick, 1000);
  </script>
</body>
</html>
